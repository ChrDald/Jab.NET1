<html>
<head>
  <title></title>
  <style type="text/css">
    .style1 {
      font-family: Arial, Helvetica, sans-serif;
      font-size: 10pt;
    }
  </style>
</head>
<body class="style1">
<p>
This sample displays the visual tree of a <b>Diagram</b>.
On the top is a simple example diagram, and on the bottom is the diagram showing 
the top diagram&#39;s visual tree.</p>
<p>
The tree diagram is constructed by using a custom <b>TreeModel</b> that uses
the actual visual elements of the visual tree used to render the diagram on the left.
The <b>VisualTreeModel</b> overrides the <b>FindChildNodeKeysForNode</b> method 
so that it can use <b>VisualTreeHelper</b> methods to get the child visual
elements for a <b>UIElement</b>.
</p>
<p>
Each node shows the name of the type of <b>UIElement</b> in the visual tree,
using an <b>ElementConverter</b> that returns a string for the element.
</p>
<p>
Next to the name is a <b>Button</b>.  The button's <b>Click</b> event handler
toggles the value of <b>Node.IsExpandedTree</b>, and changes the appearance of the button.
Note that only one of the two shapes, &quot;MinusShape&quot; and &quot;PlusShape&quot;,
is visible at any time.
</p>
<p>
But the button should only be visible when the node has visual children.
This is achieved by binding the <b>Visibility</b> property of the button to the
<b>UIElement</b> using a converter that calls <b>VisualTreeHelper.GetChildrenCount</b>
to decide if it has any visual children.
</p>
<p>
Because the <b>TreeLayout</b>'s performance conditions include <b>VisibleChanged</b>,
after a node changes visibility another layout is performed.
</p>
</body>
</html>
